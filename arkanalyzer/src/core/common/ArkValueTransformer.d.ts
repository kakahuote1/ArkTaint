import * as ts from 'ohos-typescript';
import { Local } from '../base/Local';
import { ArkAliasTypeDefineStmt } from '../base/Stmt';
import { AliasType, Type } from '../base/Type';
import { GlobalRef } from '../base/Ref';
import { ArkMethod } from '../model/ArkMethod';
import { ArkIRTransformer, ValueAndStmts } from './ArkIRTransformer';
export declare class ArkValueTransformer {
    conditionalOperatorNo: number;
    private tempLocalNo;
    private sourceFile;
    private locals;
    private globals?;
    private thisLocal;
    private declaringMethod;
    private arkIRTransformer;
    private aliasTypeMap;
    private builderMethodContextFlag;
    constructor(arkIRTransformer: ArkIRTransformer, sourceFile: ts.SourceFile, declaringMethod: ArkMethod);
    getLocals(): Set<Local>;
    getThisLocal(): Local;
    getAliasTypeMap(): Map<string, [AliasType, ArkAliasTypeDefineStmt]>;
    addNewLocal(localName: string, localType?: Type): Local;
    getGlobals(): Map<string, GlobalRef> | null;
    private addNewGlobal;
    tsNodeToValueAndStmts(node: ts.Node): ValueAndStmts;
    private tsNodeToSingleAddressValueAndStmts;
    private thisExpressionToValueAndStmts;
    private superExpressionToValueAndStmts;
    private conditionalExpressionToValueAndStmts;
    private objectLiteralExpresionToValueAndStmts;
    private generateSystemComponentStmt;
    private generateCustomViewStmt;
    private generateComponentCreationStmts;
    private generateComponentPopStmts;
    private etsComponentExpressionToValueAndStmts;
    private classExpressionToValueAndStmts;
    private templateExpressionToValueAndStmts;
    private processTemplatePlaceholders;
    private combineTemplateParts;
    private taggedTemplateExpressionToValueAndStmts;
    private collectTemplateValues;
    private identifierToValueAndStmts;
    private propertyAccessExpressionToValue;
    private elementAccessExpressionToValueAndStmts;
    private callExpressionToValueAndStmts;
    private generateInvokeValueAndStmts;
    private handleFieldRefInvoke;
    private handleLocalInvoke;
    private isCustomViewCall;
    private isSystemComponentCall;
    private handleArrayRefInvoke;
    private handleDefaultInvoke;
    private parseArgumentsOfCallExpression;
    private parseArguments;
    private callableNodeToValueAndStmts;
    private newExpressionToValueAndStmts;
    private newArrayExpressionToValueAndStmts;
    private arrayLiteralExpressionToValueAndStmts;
    private generateArrayExprFromLiteral;
    private generateArrayExprAndStmts;
    private prefixUnaryExpressionToValueAndStmts;
    private postfixUnaryExpressionToValueAndStmts;
    private awaitExpressionToValueAndStmts;
    private yieldExpressionToValueAndStmts;
    private deleteExpressionToValueAndStmts;
    private voidExpressionToValueAndStmts;
    private nonNullExpressionToValueAndStmts;
    private parenthesizedExpressionToValueAndStmts;
    private typeOfExpressionToValueAndStmts;
    private asExpressionToValueAndStmts;
    private typeAssertionToValueAndStmts;
    variableDeclarationListToValueAndStmts(variableDeclarationList: ts.VariableDeclarationList): ValueAndStmts;
    variableDeclarationToValueAndStmts(variableDeclaration: ts.VariableDeclaration, isConst: boolean, needRightOp?: boolean): ValueAndStmts;
    private assignmentToValueAndStmts;
    private assignmentRightOpToValueAndStmts;
    private arrayDestructuringToValueAndStmts;
    private objectDestructuringToValueAndStmts;
    private binaryExpressionToValueAndStmts;
    private compoundAssignmentToValueAndStmts;
    private compoundAssignmentTokenToBinaryOperator;
    conditionToValueAndStmts(condition: ts.Expression): ValueAndStmts;
    private literalNodeToValueAndStmts;
    private getOrCreateLocal;
    generateTempLocal(localType?: Type): Local;
    private isRelationalOperator;
    private isLiteralNode;
    resolveTypeNode(type: ts.TypeNode): Type;
    private resolveTypeQueryNode;
    private resolveTypeOperatorNode;
    static resolveLiteralTypeNode(literalTypeNode: ts.LiteralTypeNode, sourceFile: ts.SourceFile): Type;
    private resolveTemplateLiteralTypeNode;
    private resolveTypeReferenceNode;
    private resolveTypeLiteralNode;
    private resolveFunctionTypeNode;
    static isCompoundAssignmentOperator(operator: ts.SyntaxKind): boolean;
}
